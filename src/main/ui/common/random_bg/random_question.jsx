const Qw_1 = {
    question: 'В каких случаях Class Component лучше, чем Functional Component?',
    answer: 'Определение компонента как класса – мощная реализация, которая необходима, если компонент ' +
        'имеет состояние или значимые методы. В остальных случаях можно использовать функциональный ' +
        'компонент: он менее мощный, но более простой.'
};
const Qw_2 = {
    question: 'Что такое refs и с чем их едят?',
    answer: 'Предположим, нам понадобилось «достучаться» к конкретному элементу и вызвать метод. ' +
        'React.JS refs нужен как раз для этого. Как использовать? Добавить атрибут ref в компонент ' +
        'для обратного вызова.Примечательно, что поле ввода с атрибутом ref, а его значение – это функция' +
        ' При этом можно работать как с классом компонента, так и с функциональными компонентами, используя замыкание'
};
const Qw_3 = {
    question: 'Разница между компонентами controlled и uncontrolled?',
    answer: 'Контролируемый компонент обладает своим стейтом, управляемый React.Неконтролируемый компоненты обладает внутренним состоянием' +
        '(как например textarea'
};
const Qw_4 = {
    question: 'Как React JS Использует Ключи?',
    answer: 'React использует ключи, чтобы провести границу между простыми виртуальными элементами DOM и теми,\n' +
        ' что являются уникальными. Кроме того, ключи помогают React перерабатывать существующие элементы DOM,\n' +
        ' чтобы библиотека работала и отображалась более плавно.'
};
const Qw_5 = {
    question: 'Почему React.Children.map(props.children, () => ), а не props.children.map(() => )?',
    answer: 'А если props.children окажется не массивом, а объектом? Пример:\n' +
        '\n' +
        '<Parent>\n' +
        '  <h1>Welcome.</h1>\n' +
        '</Parent>\n' +
        'Вызов props.children.map в «родителе» даст ошибку, ведь это как раз тот случай, когда props.children – объект, ' +
        'а не массив. React отработает, если дочерний элемент не один: их должно быть несколько. Взгляните:\n' +
        '\n' +
        '<Parent>\n' +
        '  <h1>Welcome.</h1>\n' +
        '  <h2>props.children will now be an array</h2>\n' +
        '</Parent>\n' +
        'Вот почему использование React.Children.map наиболее предпочтительно: с такой реализацией props.children может' +
        ' выступать как массивом, так и объектом.'
};
const Qw_6 = {
    question: 'Опишите обработку событий в React.JS',
    answer: `Добавляет один обработчик события на корневой элемент.
     Объект события оборачивает
      в свою обертку - ​SyntheticEvent​ для кроссбраузерности`
};
const Qw_7 = {
    question: 'Как заставить компонент React перерендерится?',
    answer: ':Самый простой способ перерендерить компонента - изменить его props.' +
        ' Также вы можете сделать это, используя метод ' + 'this.setState.\n' +
        ' Наконец, метод this.forceUpdate может инициировать рендеринг. Стоит отметить, что два первых способа сначала\n' +
        ' вызовут метод shouldComponentUpdate(), поэтому, если вам нужен принудительный рендеринг, \n' +
        'используйте метод forceUpdate'
};
const Qw_8 = {
    question: 'Что произойдет, если передать функцию в метод setState ?',
    answer: 'Переданная функция будет вызвана с текущим состоянием в качестве аргумента, эта функция очень полезна, ' +
        'если вы хотите обновить состояние целостно.\n' +
        'updateBalance(amount) {\n' +
        '  this.setState((prevState) => {\n' +
        '    // Important: read `prevState` instead of `this.state` when updating.\n' +
        '    return {amount: prevState.amount + amount}\n' +
        '  });\n' +
        '}\n' +
        'handleTransaction(){\n' +
        '    this.updateBalance(10);\n' +
        '    this.updateBalance(30);\n' +
        '    this.updateBalance(50);// this.state.amount is now zero, but when component re-renders it will be 90 \n' +
        '}'
};
const Qw_9 = {
    question: 'Что такое порталы(Portals)?',
    answer: 'Порталы предоставляют первоклассный способ отображения дочерних элементов в узел DOM,\n' +
        ' который существует вне иерархии DOM родительского компонента.'
};
const Qw_10 = {
    question: 'Что такое чистый компонент и когда он должен использоваться ?',
    answer: 'PureComponent автоматически проверяет, должен ли компонент обновляться,\n' +
        ' поэтому вам не нужно писать shouldComponentUpdate самостоятельно.\n' +
        ' PureComponent будет вызывать функцию render(), \n' +
        'только если обнаруживает изменения в props или в состоянии. \n' +
        'В некоторых случаях React.PureComponent более эффективен и определенно уменьшает количество кода.'
};
const Qw_11 = {
    question: 'Что такое поднятие состояния вверх по иерархии в React (Lifting State Up)?',
    answer: 'Обычно некоторые компоненты должны реагировать на одни и те же события или изменения состояния, ' +
        'поэтому необходимо каким-то образом уведомлять все компоненты, когда что-то изменилось. Рекомендуемый способ ' +
        'сделать это-поднять состояние вверх. Это означает, что общее состояние должно быть поднято до ближайшего общего ' +
        'предка. Этот метод, основанный на утверждении что должен быть один для любых данных, которые изменяются в приложении React.'
};
const Qw_12 = {
    question: 'Что такое React Reconciliation (Cверка) и как он работает?',
    answer: 'Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM.' +
        ' Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. ' +
        'Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный ' +
        'DOM будет содержать новое состояние компонента.' +
        'По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим' +
        ' спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность ' +
        'может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить' +
        ' потомков исходного дерева с потомками последующего дерева.'
};
const Qw_13 = {
    question: 'При создании HOC,как узнать,что оборачиваемый компонент явяеться реакт компонетом' +
        ',и если нет,как добавить ему новые props\t?',
    answer: 'if(BaseComponent.prototype.isReactComponent){\n' +
        '    //add props\n' +
        '}'
};
const Qw_14 = {
    question: 'Что значит компонент mounted?',
    answer: 'Шаблон компонента соединен с DOM деревом'
};
const Qw_15 = {
    question: 'В setState можно передавать объект или функцию. В чем разница и что лучше использовать?',
    answer: 'props​ и ​state​ могут изменяться асинхронно. \n' +
        'Если мы передадим функцию, то мы точно будет знать, что стейт основывается на предыдущем состоянии'
};
const Qw_16 = {
    question: 'Назовите разницу между Презентационным и Контейнер компонентом?',
    answer: ' Презентационный - “как вещи выглядят”. Нужен для создания интерфейса.\n' +
        'Работает на входящих параметрах\n' +
        ' Контейнер - “как вещи работают”. Обладают состоянием, подключены к Flux или Redux'
};
const Qw_17 = {
    question: 'Что такое и для чего используються Higher-Order компоненты?',
    answer: 'Higher-order component (HOC) - функции, у которых входящий параметр компонент.\n' +
        'Возвращают новый компонент с добавленным поведением.\n' +
        'Могут быть использованы в следующих случаях:\n' +
        '1. Переиспользование кода\n' +
        '2. Слой абстракции для state и взаимодействия с ним\n' +
        '3. Управление props'
};
const Qw_18 = {
    question: 'Что нельзя делать в методе render?',
    answer: 'Нельзя изменять состояние компонента (например вызывать ​setState​). Должен быть чистой (pure) функцией'
};

const Qw_19 = {
    question: 'Почему не стоит изменять state напрямую?',
    answer: 'Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. Корректно использовать метод ​setState()'
};
const Qw_20 = {
    question: 'Как изменить state используя динамический ключ?',
    answer: 'InputChageHandlet(event){\n' +
        'this.setState({\n' +
        '[event.target.name]:event.target.value})\n' +
        '}'
};
const Qw_21 = {
    question: 'Что такое Error Boundaries в React?',
    answer: 'React - компонент, позволяющий обрабатывать ошибки в дочерних компонентах.\n' +
        ' Для это присутствует метод ​componentDidCatch(error, info)'
};
const Qw_22 = {
    question: 'В чем разница между useRef и createRef?',
    answer: ' createRef​ - всегда создает новую ссылку. Используется в class компонентах\n' +
        ' useRef​ - возвращает одинаковую ссылку на объект, который был при начальном рендеринге'
};
const Qw_23 = {
    question: 'Что такое prop drilling и как этого избежать?',
    answer: 'Передача свойств на прямую от родителя к ребенку через сложную и длинную иерархию компонентов.\n' +
        'Избежать можно используя ​Context​ или например ​Redux​ (Flux)'
};
const Qw_24 = {
    question: 'Зачем делать eject?',
    answer: 'На случай, если необходимо модифицировать конфигурацию проекта (webpack, babel)'
};
const Qw_25 = {
    question: 'Разница между Flux и MVC?',
    answer: 'На случай, если необходимо модифицировать конфигурацию проекта (webpack, babel)\n' +
        'MVC (model view controller) - \n' +
        'парадигма, разделяющая отображение и данные, однако присутствуют следующие минусы:\n' +
        '● каскадная модель данных, сложно отслеживать состояние\n' +
        '● данные могут быть изменены где угодно. Как следствие непредсказуемое поведение UI\n' +
        'Flux позволяет решить проблему каскадной модели данных. \n' +
        'Данные получаются из отдельного store и менять напрямую их нельзя.'
};
const Qw_26 = {
    question: 'Как работает проп children?',
    answer: 'Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog,' +
        ' которые представляют из себя как бы «коробку», в которую можно что-то положить.' +
        ' Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние ' +
        'элементы сразу на выводChildren заставляют компоненты в React вести себя как элементы разметки, а не отдельные объекты'
};
const Qw_27 = {
    question: 'Можно создавать анимации в React?',
    answer: 'React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group' +
        ' и React Motion.'
};
const Qw_28 = {
    question: 'Что не так с этим кодом?\n' +
        'this.setState((prevProps,props))=>{\n' +
        'return{\n' +
        'couter:prevProps.counter+props.counter\n' +
        '}\n' +
        '})',
    answer: 'С этим кодом все хорошо. Изменяем state на основе прошлого состояния и входящих параметров'
};
const Qw_29 = {
    question: 'Какой второй опциональный параметр можно передать в метод setState и за что он отвечает?',
    answer: 'Функция, уведомляющая, что компонент закончил процесс ре-рендеринга.'
};
const Qw_30 = {
    question: 'Что такое React Fiber?',
    answer: 'Fiber - это новый механизм и базовый алгоритм для рендеринга в React 16.\n' +
        ' Основная цель - реализовать пошаговый рендеринг виртуального DOM для более быстрого рендеринга,\n' +
        ' работы с анимациями и дебагом.'
};
const Qw_31 = {
    question: 'Разница между Flow и PropTypes?',
    answer: ' Flow​ - статический инструмент для проверки типов.\n' +
        ' Использует аннотации и позволяет найти ошибки при компиляции (аналог TypeScript)\n' +
        ' PropTypes​ - проверяет типы входящих параметров в runtime'
};
const Qw_32 = {
    question: 'Правда ли, что React делает ре-рендер всех компонентов и\n' +
        ' дочерних компонентов каждый раз когда вызывается setState?',
    answer: 'По умолчанию - да. Однако мы этим можем управлять в shouldComponentUpdate(nextProps, nextState)​.'
};
const Qw_33 = {
    question: 'Как можно улучшить производительность React приложения?',
    answer: 'Для этого можно использовать:\n' +
        '1. shouldComponentUpdate​ в класс компонентах\n' +
        '2. PureComponent​ для класс компонентов\n' +
        '3. React.memo()​ - для функциональных компонентов' +
        '4. хуки useMemo,useCallback в функциональных компонентах'
};
const Qw_34 = {
    question: 'Что можно сделать с помощью хуков, чего невозможно добиться, используя классы?',
    answer: 'Хуки дают новый мощный способ повторного использования кода в компонентах.'
};
const Qw_35 = {
    question: 'Являются ли хуки заменой рендер-пропсам и компонентам высшего порядка?',
    answer: 'Как правило, рендер-пропсы и компоненты высшего порядка рендерят только один дочерний компонент,\n' +
        ' увеличивая вложенность в дереве, но добавляя потомку новую функциональность.\n' +
        ' Хуки — более простой способ сделать это,но в отличие  от рендер-пропсов и HOC\n' +
        '  в большинстве случаев хуки могут уменьшить вложенность компонентов в вашем дереве.'
};
const Qw_36 = {
    question: 'Безопасно ли не указывать функции в списке зависимостей useEffect?',
    answer: 'лучше объявлять функции нужные эффекту внутри него\n' +
        'function Example({ someProp }) {\n' +
        '  useEffect(() => {\n' +
        '    function doSomething() {\n' +
        '      console.log(someProp);\n' +
        '    }\n' +
        '\n' +
        '    doSomething();\n' +
        '  }, [someProp]); // ✅ Правильно (наш эффект использует только `someProp`)\n' +
        '}'
};
const Qw_37 = {
    question: 'Как избежать передачи колбэков вниз(Hooks)?',
    answer: 'передавать вниз функцию dispatch из хука useReducer через контекст\n' +
        'function DeepChild(props) {\n' +
        '  // Если мы хотим выполнить действие, мы можем получить dispatch из контекста.\n' +
        '  const dispatch = useContext(TodosDispatch);\n' +
        '\n' +
        '  function handleClick() {\n' +
        '    dispatch({ type: \'add\', text: \'Привет\' });\n' +
        '  }\n' +
        '\n' +
        '  return (\n' +
        '    <button onClick={handleClick}>Добавить задание</button>\n' +
        '  );\n' +
        '}'
};
const Qw_38 = {
    question: 'Как React связывает вызовы хуков с компонентом?',
    answer: 'Существует внутренний список ячеек памяти, связанных с каждым компонентом.' +
        'Они являются JavaScript-объектами, в которых мы можем хранить некоторые данные.\n' +
        ' Когда вызывается некий хук, например useState(), он читает значение текущей ячейки \n' +
        '(или инициализирует её во время первого рендера) и двигает указатель на следующую. \n' +
        'Таким способом каждый вызов useState() получит своё независимое состояние. '
};
const Qw_39 = {
    question: 'Почему нельзя использовать HOC внутри render метода.',
    answer: 'При рендере каждый раз создаёться новый оборачиваемый компонент,таким образом,каждый раз монтируеться и \n' +
        'размонтируеться всё потдерево этого компонета,всё это влияет на проихводительнось приложения. \n' +
        '2.Повторное монтирование компонента обнуляет его состояние, а также состояние его дочерних компонентов.'
};
const Qw_40 = {
    question: 'Может ли HOC передать оборачиваемому копонету ref?Почему так?',
    answer: 'По соглашению компоненты высшего порядка передают оборачиваемому\n' +
        ' компоненту все пропсы, кроме рефов. ref на самом деле не проп, как, например, key, \n' +
        'и поэтому иначе обрабатывается React. Реф элемента, созданного компонентом из HOC, будет указывать\n' +
        ' на экземпляр ближайшего в иерархии контейнера, а не на оборачиваемый компонент.'
};
const Qw_41 = {
    question: 'Что такое Profiler?',
    answer: 'Profiler измеряет то, как часто рендерится React-приложение и какова «стоимость» этого.\n' +
        ' Его задача — помочь найти медленные части приложения, которые можно оптимизировать (например, через мемоизацию).\n' +
        'Profiler может быть добавлен в любую часть React-дерева для измерения стоимости рендеринга этой части. \n' +
        'Он принимает два пропа: id (string) и колбэк onRender (function), который React вызывает каждый раз,\n' +
        ' когда компонент внутри дерева «фиксирует» обновление.'
};
const Qw_42 = {
    question: 'Почему нельзя использовать  рендер-проп вместе с React.PureComponent?',
    answer: 'Использование рендер-пропа может свести на нет преимущество, которое даёт React.PureComponent, \n' +
        'если вы создаёте функцию внутри метода render. Это связано с тем,\n' +
        ' что поверхностное сравнение пропсов всегда будет возвращать false\n' +
        ' для новых пропсов и каждый render будет генерировать новое значение для рендер-пропа.'
};
const Qw_43 = {
    question: 'Зачем нужен хук useReducer?',
    answer: 'Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, \n' +
        'которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.' +
        ' useReducer также позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, \n' +
        'поскольку вы можете передавать dispatch вместо колбэков'
};
const Qw_44 = {
    question: 'Как пользовательский хук получает изолированное состояние?',
    answer: 'Каждый вызов хука получает изолированное состояние. \n' +
        'Поскольку мы вызываем пользовательский хук напрямую, с точки зрения React\n' +
        ' наш компонент просто вызывает useState и useEffect. И как мы узнали ранее,\n' +
        ' мы можем вызывать useState и useEffect много раз в одном компоненте, и они будут полностью независимы.\n' +
        'Пользовательские хуки — это механизм повторного использования логики с состоянием\n' +
        ' (например, установка подписки и сохранение текущего значения),\n' +
        ' но каждый раз, когда вы используете пользовательский хук, всё состояние и эффекты внутри него полностью \n' +
        'изолированы.'
};
const Qw_45 = {
    question: 'Что такое Context?',
    answer: 'Context - позволяет передавать свойства от родителя к ребенку, избегая промежуточных компонентов'
};
const Qw_46 = {
    question: 'В каких лучаях не стоит использовать Context ?',
    answer: 'Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных \n' +
        'уровнях вложенности. По возможности не используйте его, так как это усложняет повторное использование компонентов.\n' +
        'Если вы хотите избавиться от передачи некоторых пропсов на множество уровней вниз, \n' +
        'обычно композиция компонентов является более простым решением, чем контекст.'
};
const Qw_47 = {
    question: 'Что такое доступность контента?',
    answer: 'Доступность контента — это специальные технические и архитектурные решения,\n' +
        ' которые помогают людям с ограниченными возможностями использовать сайты. \n' +
        'Применение таких решений необходимо для интерпретации страниц техническими средствами реабилитации,\n' +
        ' встроенными в операционные системы и браузеры. Термин «доступность контента» также может обозначаться\n' +
        ' аббревиатурой a11y.'
};
const Qw_48 = {
    question: 'Назовите основные этапы жизненного цикла компонента',
    answer: '● componentWillMount​ - перед рендерингом, в основном для настройки компонента\n' +
        '● render​ - процесс рендеринга\n' +
        '● componentDidMount​ - уведомляет, про то, что компонент соединен с DOM деревом\n' +
        '● componentWillReceiveProps​ - уведомляет, про то, что приходят новые входящие свойства в компонент\n' +
        '● shouldComponentUpdate​ - возвращает true или false и служит для оптимизации. Решает, нужно ли делать ре-рендеринг\n' +
        '● componentWillUpdate​ - уведомляет, что компонент будет обновлен\n' +
        '● componentDidUpdate​ - уведомляет, что компонент был обновлен\n' +
        '● componentWillUnmount​ - используется для удаления слушателей и очистки компонента. Вызывается перед удалением компонента\n'
};
const Qw_49 = {
    question: ' Что такое JEST?', answer: 'JavaScript фреймворк, для юнит тестирования на основе Jasmine. Разработал' +
        'Facebook. Очень удобен именно для React'
};
const Qw_50 = {
    question: ' В чем разница между state и props?',
    answer: ' state- структура данных, необходимая для изменения и отслеживания' +
        'пользовательских действий' +
        'props- - набор конфигурации, поступающий от родительского элемента. Их нельзя изменять'
};
const Qw_51 = {
    question: ' Что происходит, когда вы вызываете setState?',
    answer: ' Вначале React соединяет объект стейта с измененными полями. На основе нового' +
        'состояния строит новое дерево React элементов и выясняет, какие именно части' +
        'приложения должны быть изменены Это нужно для наиболее производительного обновления интерфейса'
};
const Qw_52 = {
    question: ' Когда следует делать асинхронные запросы на сервер в React ?',
    answer: ' Для этого служит метод componentDidMount Или useEffect  с пустым набором зависимостей'
};
const Qw_53 = {
    question: ' Что такое фрагменты?',
    answer: ' Специальный элемент в React позволяющий возвращать группу элементов без' +
        'дополнительного родительского DOM элемента'
};
const Qw_54 = {
    question: ' Что делает shouldComponentUpdate и почему он важен??',
    answer: ' Этап жизненного цикла, который решает, будет ли ре-рендер, или нет' +
        'Позволяет оптимизировать приложение'
};
const Qw_55 = {
    question: ' Что такое store в Redux?',
    answer: ' JavaScript объект, в котором содержится состояние приложения. Дополнительно' +
        'отвечает за следующее:' +
        '1 state может быть получен через getState ' +
        '2 Изменять state можно через dispatch(action)' +
        '3.Регистрировать изменения через subscribe(listener) '
};
const Qw_56 = {
    question: '  Почему не стоит изменять state напрямую?',
    answer: ' Не будет запущен процесс ре-рендеринга и интерфейс не поменяется. Корректно' +
        'использовать метод setState()'
};
const Qw_57 = {
    question: ' Что такое Error Boundaries в React?',
    answer: ' React - компонент, позволяющий обрабатывать ошибки в дочерних компонентах. Для' +
        'это присутствует метод componentDidCatch(error, info) '
};
const Qw_58 = {
    question: '  Что такое useState?',
    answer: ' Встроенные React хук. Позволяет работать со стейтом в функциональных' +
        'компонентах. Принимает начальное значение. Возвращает массив, состоящий всегда' +
        'из 2х элементов (кортеж), где: ' +
        'первый элемент - само состояние' +
        'второй элемент - функция, меняющая состояние '
};
const Qw_59 = {
    question: ' Что такое reducer?',
    answer: ' Простая чистая функция, принимающая state и action и модифицирующая state '
};
const Qw_60 = {
    question: ' Что такое mapStateToProps и mapDispatchToProps??',
    answer: ' Функции в Redux, позволяющие приводить к более удобному формату данные из store в компонент '
};
const Qw_61 = {
    question: 'Какие типы middleware есть в redux для работы с асинхронностью?',
    answer: '1. Redux Thunk\n' +
        '2. Redux Promise\n' +
        '3. Redux Saga'
};


let questionArray =[Qw_1,Qw_2,Qw_3,Qw_4,Qw_5,Qw_6,Qw_7,Qw_8,Qw_9,Qw_10,Qw_11,Qw_12,Qw_13,Qw_14,Qw_15,Qw_16,Qw_17,Qw_18,Qw_19,
    Qw_20,Qw_21,Qw_22,Qw_23,Qw_24,Qw_25,Qw_26,Qw_27,Qw_28,Qw_29,Qw_30,Qw_31,Qw_32,Qw_33,Qw_34,Qw_35,Qw_36,Qw_37,Qw_38,Qw_39,
    Qw_39,Qw_40,Qw_41,Qw_42,Qw_43,Qw_44,Qw_45,Qw_46,Qw_47,Qw_48,Qw_49,Qw_50,Qw_51,Qw_52,Qw_53,Qw_54,Qw_55,Qw_56,Qw_57,Qw_58,Qw_59,Qw_60,Qw_61]


export let maxNumber = questionArray.length;
export let cardQuestion;

export const getRandomQuestion = (maxNumber) => {
    let number = Math.floor(Math.random() * (maxNumber));
    return cardQuestion = questionArray[number];
}

getRandomQuestion(maxNumber);

